function [fgHit fgFa dwi nifti hitRoiCoords faRoiCoords] = mctSimulateFG(fiberType,bval, nbvecs, S0,ns,mmPerNode,numClones)
%
% function [fgHit fgFA dwi nifti hitRoiCoords faRoiCoords] = mctSimulateFG(fiberType,bvals, bvecs,S0,ns,mmPerNode,numClones)
%
% Simulate a fiber group and generate the diffusion signal out of the fiber
% group.
%
% Inputs:
%  - fiberType: Slects varioaus possible fiber scenarios.
%    {'kc2','kissing curved 2d'}    Two kissing fibers.
%    {'cs2','crossing straight 2d'} Two crossing fibers.
%    {'ps2','parallel straight 2d'} Two parrallel fibers in different
%                                   voxels.
%    {'kc2fa','kissing curved 2d'}    Two kissing fibers plus, all possible 
%                                     false alarm fibers.
%    {'cs2fa','crossing straight 2d'} Two crossing fibers, all possible 
%                                     false alarm fibers.
%    {'ps2fa','parallel straight 2d'} Two parrallel fibers in different, all 
%                                     possible false alarm fibers.
% 
% - *bval* is the the b value, e.g., 800, 100, 2000, 3000. It is rescaled to m^2/s
% - *nbvecs* is the number of diffusion directions measured, e.g., 12, 90, 150 etc.
% - *S0* is the signal for the non-diffusion direction (mean diffusivity), e.g., 500 
% - *ns* is a scaling parameter for the amount of noise being added to the
%        data, it is multiplied by the signal standard deviation to generate the
%        spread of the rician noise distribution. 
%        ns = 0.125 is a low noise level
%        ns = 0.5 is a relatively high noise level (noise is half the variability 
%        of the diffusion signal)
% - *numClones* The number of clones of each initial fiber in a fiber group.
%               Each fiber in a fiber group is cloned by added variability
%               around the x,y,z coordinates of each of its nodes.
% 
% Outputs:
%  - fgHit and fgFa are two fiber groups containing real fibers and
%    false fibers.
%  - dwi is a structure containing the diffusion signal generated by the real fibers (fghit)  
%  - nifti is a nifit file structure containing the diffusion signal in
%    dwi.
%  - hitRoiCoords are the voxel coordinates where the fgHit fibers go
%    through.
%  - faRoiCoords are the voxel coordinates where the fgFa fibers go through. 
%
% Example: 
%     % create a new fiber group
%     S0     = 500; % Mean diffusivity
%     nbvecs = 12;
%     bval   = 800;
%     fiberType = 'kc2';
%     nFiber = 2;
%     ns     = 0.125
%     [fg dwi nifti coords] = mctSimulateFG(fiberType, bval, nbvecs, S0,ns);
%
% See also, s_mct_simulated
%
% Franco
%
% (C) 2012 Stanford VISTA team. 

% Check if the noise params was passed in.
if notDefined('ns'),ns=[];end;

% plot the fibers 
plotFG = 1;

%% Call up the function that generates the fibers.
% make HIT fibers to use for building the diffusion signal
[fgHit, volSiz, niftiFileName] = makeHitFibers(fiberType);
numHitFibers = length(fgHit.fibers);

% make FA fibers, not used to build the diffusion signal
[fgFa] = makeFaFibers([fiberType,'fa']);
numFaFibers= length(fgFa.fibers);

% Clone each fiber to increase the number of fibers.
if ~notDefined('numClones')
    fgHit = fgClone(fgHit,numClones);
    fgFa  = fgClone(fgFa,numClones);
end

% Increase the number of nodes if requested, 
% default node number is one per voxel
if ~notDefined('mmPerNode')
    fgHit = fgInterp(fgHit,mmPerNode);
    fgFa  = fgInterp(fgFa,mmPerNode);
end
  
% Make 3d plot of the fibers
if plotFG
    mctPlotFibers(fgHit,'Hits',numHitFibers,mmPerNode);
    set(gcf,'Position',[1640 678 560 420])

    mctPlotFibers(fgFa,'False Alarms', numFaFibers,mmPerNode);    
    set(gcf,'Position',[789 678 560 420])

end

%% Generate proper bvecs and bvals
% We using Camino's precomputed bvecs
bvecs = mctSimulateBvecs(nbvecs);
% We transform in units of um2/s
bvals = bval * ones(size(bvecs,1),1) / 1000;

%% Generate a dwi volume with 0-signal everywhere except where the fibers go through.
% choose the unique coordinates the fibers go through.
hitRoiCoords = fefgGet(fgHit,'unique image coords');
faRoiCoords  = fefgGet(fgFa,'unique image coords');

% Number of voxels in the hitRoiCoords
nVoxels = size(hitRoiCoords,1); 

% For each voxel, compute the pairing of fiber index and the node index.
voxel2FNpair = fefgGet(fgHit,'voxel 2 fiber node pairs',hitRoiCoords);

% Compute the tensors for each fibers. 
disp('Computing fibers'' tensors (fgTensor.m)');
d_ad = 1.5; d_rd = 0.5;
dParms(1) = d_ad; dParms(2) = d_rd; dParms(3) = d_rd;
fgHit.Q   = fgTensors(fgHit, dParms);
fgFa.Q    = fgTensors(fgFa, dParms);

nNodes    = zeros(1,nVoxels);  % Number of nodes in each voxel
nodesDsig = cell(1,nVoxels);
voxDsig   = nan(nVoxels,nbvecs);
for vv  = 1:nVoxels
    % Number of nodes in each voxel.
    nNodes(vv) = size(voxel2FNpair{vv},1);
    
    % Compute tensors for each node.
    thisQ{vv} = zeros(nNodes(vv), 9); % Allocate space for all the tensors (9 is for the 3 x 3 tensor components)
    for ii = 1:nNodes(vv)           % Get the tensors
        thisQ{vv}(ii,:) = fgHit.Q{voxel2FNpair{vv}(ii,1)}(voxel2FNpair{vv}(ii,2),:);
    end
    
    % Generate dwi signal for each node.
    for ii = 1:nNodes(vv) 
        nodesDsig{vv}(ii,:) = dwiComputeSignal(S0,bvecs,bvals,thisQ{vv}(ii,:));
    end
    
    % Generate  the signal for each voxel.
    voxDsig(vv,:) = sum(nodesDsig{vv},1);
end

% build a volume for the dwi, filled with zeros
dwi_data = zeros(volSiz(1),volSiz(2),volSiz(3),nbvecs + 1);   

%% Add Rician noise if requested
% We add rician noise in each voxel with parameter mu and sd selected
% depedning on whether the voxel has fibers going through them or not.
%
% Parameters for non-fiber voxels: mu=0, sd=ns*std(voxDsig(:)) 
% Parameters for fiber voxels:     mu=mean(voxDsig(vv,:)), sd = sn*std(voxDsig(:))

% Non-fiber voxels.
if ~isempty(ns)
    sd = ns * std(voxDsig(:));
    n  = mctComputeRiceNoise(0,sd,size(dwi_data));

    % add the noise to the dwi data
    dwi_data = dwi_data + n;    
    %mrvNewGraphWin;
    %hist(dwi_data(:),length(n(:)));
end

% Fiber voxels.
% add the dwi signal generated with the fiber in each voxel
% add also rician noise if necessary.
for vv = 1:size(hitRoiCoords,1)
    if ~isempty(ns) % Add Rician Noise
        sd = ns * std(voxDsig(:)); % is this the best way?
        n = mctComputeRiceNoise(mean(voxDsig(vv,:)),sd,size(voxDsig(vv,:)));
    else
        n = 0;
    end
    dwi_data(hitRoiCoords(vv,1),hitRoiCoords(vv,2),hitRoiCoords(vv,3),1:nbvecs) = voxDsig(vv,:) + n;
end

% Add the non-diffusion direction signal and bvecs/bvals in last position
%dwi_data(:,:,:,end) = S0 * ones(volSiz(1),volSiz(2),volSiz(3)) + mctComputeRiceNoise(S0,ns*S0,volSiz);
bvecs = [bvecs; zeros(1,3)];
bvals = [bvals; 0];

% Make a nifti file structure and a dwi structure.
nifti = niftiGetStruct(dwi_data);
nifti = setfield(nifti,'descrip','Simulated diffusion nifti data');
nifti = setfield(nifti,'fname',niftiFileName);
dwi   = dwiCreate('name','Simulated DWI data','nifti',nifti,'bvecs',bvecs,'bvals',bvals);


%%%%%%%%%%%%%%%%%
% makeHitFibers %
%%%%%%%%%%%%%%%%%
function [fg volSiz nfn] = makeHitFibers(fiberType)   
% 
% function [fg volSiz nfn] = makeHitFibers(fiberType,nodesPerVox)   
% 
% this function creates three cartoon example fibers
% for the microtrack paper.
%
% It creates either:
% - two crossing straight fibers, fibers cross in a single voxel
% - two parallel and independent (going trhough different voxels) fibers
% - two kissing fibers, fibers join for 3 of the 5 total voxels
%
% Fibers are contained in a 5x5x1 voxel volume.
%
% (C) 2012 Stanford VISTA team.

fg = fgCreate('name','Simulated fiber group','coordspace','img');

switch fiberType    
    case {'cs2','crossing straight 2d', 'cs2fa', ...
          'crossing straight 2d with false alarms'}
        fg.name = 'Two simulated crossing fibers';
        fg.colorRgb  = [200 50 50];
        fg.fibers    = {};
        fg.fibers{1} = [1 2 3 4 5; 3 3 3 3 3; 1 1 1 1 1];
        fg.fibers{2} = [3 3 3 3 3; 1 2 3 4 5; 1 1 1 1 1];
          
        % nifti file name
        nfn = 'mct_simulated_crossing_fibers';
        
    case {'ps2','parallel straight 2d', 'ps2fa', ...
          'parallel straight 2d with false alarms'} 
        fg.name = 'Two simulated parallel fibers';
        fg.colorRgb  = [50 200 50];
        fg.fibers    = {};
        fg.fibers{1} = [1 2 3 4 5; 2 2 2 2 2; 1 1 1 1 1];
        fg.fibers{2} = [1 2 3 4 5; 3 3 3 3 3; 1 1 1 1 1];
        
        % nifti file name
        nfn = 'mct_simulated_parallel_fibers';
        
    case {'kc2','kissing curved 2d', 'kc2fa', ...
          'kissing curved 2d with false alarms'}
        fg.name = 'Two simulated kissing fibers';
        fg.colorRgb  = [200 50 50];
        fg.fibers    = {};
        fg.fibers{1} = [1 2 3 4 5 5; 1 2 3 3 2 1; 1 1 1 1 1 1];
        fg.fibers{2} = [1 2 3 4 5 5; 5 4 3 3 4 5; 1 1 1 1 1 1];
       
        % nifti file name
        nfn = 'mct_simulated_kissing_fibers';    
    
    case {'dc4','diverging curved 2d', 'dc2fa', ...
          'diverging curved 2d with false alarms'}
        fg.name = 'Four simulated branching out fibers';
        fg.colorRgb  = [150 100 50];
        fg.fibers    = {};
        fg.fibers{1} = [1 2 3 4 5; 1 2 3 3 3; 1 1 1 1 1];
        fg.fibers{2} = [2 3 4 5; 1 2 3 3; 1 1 1 1];
        fg.fibers{3} = [1 2 3 3 3; 2 3 3 3 3; 1 1 1 1 1];
        fg.fibers{4} = [1 2 3 4 5; 3 3 3 3 3; 1 1 1 1 1];
        fg.fibers{5} = [5 4 3 2 1; 3 3 3 4 5; 1 1 1 1 1];
        fg.fibers{6} = [5 4 3  2; 3 3 4 5; 1 1 1 1];

        % nifti file name
        nfn = 'mct_simulated_diverging_fibers';
end
     
% produce a dwi volume size
volSiz = [5, 5, 1];


%%%%%%%%%%%%%%%%%
% makeFaFibers %
%%%%%%%%%%%%%%%%%
function [fg volSiz nfn] = makeFaFibers(fiberType)   
% 
% function [fg volSiz nfn] = makeHitFibers(fiberType,nodesPerVox)   
% 
% this function creates three cartoon example fibers of false-alarm fibers
% for the microtrack paper.
%
% It adds fibers to the fiber created by makeHitFibers.
%
% (C) 2012 Stanford VISTA team.

fg = fgCreate('name','Simulated FA fiber group','coordspace','img');

switch fiberType    
    case {'cs2fa','crossing straight 2d with false alarms'} 
        fg.name = 'Two simulated crossing fibers with false alarms';
        fg.fibers{1} = [3 3 3 4 5; 1 2 3 3 3; 1 1 1 1 1];
        fg.fibers{2} = [5 4 3 3 3; 3 3 3 4 5; 1 1 1 1 1];
        fg.fibers{3} = [3 3 3 2 1; 1 2 3 3 3; 1 1 1 1 1];
        fg.fibers{4} = [1 2 3 3 3; 3 3 3 4 5; 1 1 1 1 1];
          
        % nifti file name
        nfn = 'mct_simulated_crossing_fibers_fa';
        
    case {'ps2fa','parallel straight 2d with false alarms'} 
        fg.name = 'Two simulated parallel fibers with false alarms';
        fg.fibers{1} = [1 2 3 4 5; 2 2 3 3 3;1 1 1 1 1];
        fg.fibers{2} = [1 2 3 4 5; 2 2 2 3 3;1 1 1 1 1];
        fg.fibers{3} = [1 2 3 4 5; 3 3 2 2 2;1 1 1 1 1];
        fg.fibers{4} = [1 2 3 4 5; 3 3 3 2 2; 1 1 1 1 1];
        
        % nifti file name
        nfn = 'mct_simulated_parallel_fibers_fa';
        
    case {'kc2fa','kissing curved 2d with false alarms'}
        fg.name = 'Two simulated kissing fibers with false alarms';     
        fg.fibers{1} = [1 2 3 4 5 5; 1 2 3 3 4 5; 1 1 1 1 1 1];
        fg.fibers{2} = [1 2 3 2 1; 1 2 3 4 5; 1 1 1 1 1];
        fg.fibers{3} = [5 5 4 5 5; 1 2 3 4 5; 1 1 1 1 1];
        fg.fibers{4} = [5 5 4 3 2 1; 1 2 3 3 4 5; 1 1 1 1 1 1];

        % nifti file name
        nfn = 'mct_simulated_kissing_fibers_fa';    
    
    case {'dc4','diverging curved 2d', 'dc4fa', ...
          'four diverging curved 2d with false alarms'}
        fg.name = 'Simulated branching out fibers with false alarms';  
        fg.fibers{1} = [1 2 4 4 5; 1 2 3 3 3; 1 1 1 1 1];
        fg.fibers{2} = [2 3 4 5; 1 3 3 3; 1 1 1 1];
        fg.fibers{3} = [1 2 3 4 5; 2 2 3 3 3; 1 1 1 1 1];
        fg.fibers{4} = [1 2 3 4 5; 5 3 3 3 3; 1 1 1 1 1];
        fg.fibers{5} = [5 4 3 2 1; 3 3 4 4 5; 1 1 1 1 1];
        fg.fibers{6} = [5 4 3  2 1; 3 3 4 3 1; 1 1 1 1 1];
        fg.fibers{7} = [5 4 3 2 1 1 1 2 3 3 4; 3 3 2 1 2 3 3 5 3 3 3;1 1 1 1 1 1 1 1 1 1 1];

        % nifti file name
        nfn = 'mct_simulated_diverging_fibers_fa';
        
    otherwise
        keyboard
end


% produce a dwi volume size
volSiz = [5, 5, 1];


%%%%%%%%%%%%
% fgInterp %
%%%%%%%%%%%%
function fg = fgInterp(fg,mmPerNode)
% interpolate the fibers to get more nodes per voxels.

for ff = 1:length(fg.fibers)    
    y  = fg.fibers{ff};
    x  = 1:size(y,2);    
    xi = 1:1/mmPerNode:size(fg.fibers{ff},2);
    fg.fibers{ff} = [];
    for ic = 1:3 % x,y,z dimensions
      keyboard
      
        yi  = interp1(x,y(ic,:),xi,'pchip'); % spline makes unwanted curves
        fg.fibers{ff} =[fg.fibers{ff}; yi];
    end
   
end


%%%%%%%%%%%
% fgClone %
%%%%%%%%%%%
function fg = fgClone(fg,numClones)
% Clones each fiber in a fiber group
% By sampling the coordinates of each node from a gaussian distribution
% around each coordinate

% define the interval of sampling around each coordinate
% The interval used to random sample the new set of coordinates is a
% proportion of the voxel size (voxel Size = 1 mm);
vp = 0.05;

fgTemp = fg;

% Resample the coordinate
count = 1;
for ii = 1:length(fg.fibers)
   this_f = fg.fibers{ii};
   for ic = 1:numClones
      fgTemp.fibers{count} = this_f + vp*randn(size(this_f));
      count = count + 1;
   end
end

% Merge the original fiber group with the cloned fibers
fg = fgMerge(fg,fgTemp,fg.name);



