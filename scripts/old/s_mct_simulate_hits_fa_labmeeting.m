function s_mct_simulate_hits_fa_labmeeting
% 
% function s_mct_simultate_hits_fa_labmeeting
%
% Thi sfunction has been modified to geenrate all the plots for lab meeitng
% on April 2nd 2012.
%
%
% This function shows that given a fiber group containing hit-fibers and
% false-alarms fibers, LiFe can estimate the weights set for the *real*
% fibers (fibers really present in a volume of tissue) and eliminate
% (zero-out the weights for) the *fake* fibers (fibers not present in a
% tissue volume but mistakenly generated by a tracktography algorithm).
%
% The function does the following: 
% (1) simulates a few fibers.
%     - Some of these fibers are Hit-fibers, fibers assumed to be present in
%     a tissue volume. 
%     - The rest of the fibers are False Alarms fibers,
%     fibers assumed not to be present in the same tissue volume.
%
% (2) Generates diffusion signal using the Hits fibers only. Allowing the
%     weights for the fibers to be set as values between 0-1.
% (3) Merges the two fiber groups (Hits and FA). To generate the fiber
%     group that a tracktography algorithm could have generated given the
%     signal in the volume.
% (4) Set up the LiFe model using the merged fiber group.
% (5) Finds the weights for each fiber in the merged Fiber group (Hits+FA)
% (6) Estimates the variability of the estimated weights by bootstrapping (5) 
%     and adding Rician noise to the diffusion signal at each bootstrap
%     iteration.
% (7) Plots the estimated weights for each fiber with two-tailed 95%
%     confidence intervals (red) and the weights of the fibers used to simulate
%     the diffusion signal.
%
% Example: 
%
%    s_mct_simulate_hits_fa
%
% See also, test_mictrotrack_simulated_signal_recover
%
% (C) 2011 Stanford VISTA team. 

plotTensors   = 1; % make a figure of the tensors
fitType       = 'lsqnonneg'; % solver
S0            = 30; % Mean diffusivity
nbvecs        = 12;
bval          = 1000;
fiberType     = 'cs2'; % 'kc2', 'cs2', 'ps2', 'dc4'
noiseLevel    = 1.50;%[0.32,0.64,1.28]; % this is the noise level relative to the standard deviation of the signal in a voxel
sampleSpacing = 5;% 2 4 8 16 32 64];  % Change this into units. Changing this will not run, because more voxels will be required for the FA fibers.
numClones     = 1;
clones_sd     = 0.1; % standard devian of the gaussian process centered at x,y,z coords of each node, in mm.
nBoots        = 500; % number of montecarlo-simulations

for nn = 1:length(noiseLevel)
  switch noiseLevel(nn)
    case 0.08
      nl = '0_08';
    case 0.16
      nl = '0_16';
    case 0.32
      nl = '0_32';
    case 0.64
      nl='0_64';
    case 1.28
      nl = '1_28';  
    case 1.5
      nl = '1_5';
    otherwise
      keyboard
  end
  
fig_dir = sprintf('fig_%idir_%s_%i_clones_noise%s_%i_S0%i_labmeeting_20120402',nbvecs,fiberType,numClones,nl,bval,S0);
%fig_dir = 'fig_3d_labmeeting_20120402';

for ss = 1:length(sampleSpacing)
[fgHit, fgFa, dwi] = mctSimulateFG2(fiberType, bval, nbvecs, S0,noiseLevel(nn),sampleSpacing(ss),numClones,clones_sd);

mctNfgDisplayStrands(fgHit);
mctNfgDisplayStrands(fgFa);
keyboard

% Write the fibers to file (pbd).
%fgWrite(fgHit,fgHit.name,'pdb');
%fgWrite(fgFa,fgFa.name,'pdb');
%dwiNiftiFile = dwi.nifti.fname;
%niftiWrite(dwi.nifti,dwiNiftiFile);
    
% plot the tensors at the nodes
if plotTensors
    fgH = fgExtract(fgHit,1, 'keep'); 
    mctPlotFibers(fgH,'Hit1',1,sampleSpacing);    
 
    fgH = fgExtract(fgHit,2, 'keep'); 
    mctPlotFibers(fgH,'Hit2',1,sampleSpacing);     
 
    fgF = fgExtract(fgFa,1, 'keep');  
    mctPlotFibers(fgF,'False Alarm1',1,sampleSpacing);
    
    fgF = fgExtract(fgFa,2, 'keep');        
    mctPlotFibers(fgF,'False Alarm2',1,sampleSpacing);
   
    fgF = fgExtract(fgFa,3, 'keep');    
    mctPlotFibers(fgF,'False Alarm3',1,sampleSpacing);
   
    fgF = fgExtract(fgFa,4, 'keep');    
    mctPlotFibers(fgF,'False Alarm4',1,sampleSpacing);
    % savefigvista(gcf, sprintf('fgFa4_nNodes%i',sampleSpacing(ss)), 'eps',fig_dir)

end

% Merge Hits and FA fibers
name = 'Merged Hits+FAs';
fg   = fgMerge(fgHit,fgFa,name);

% Make a fiber group combining Hits and Fa, but setting the tensors for the
% FA fiebers to CSF. THis will allow us to create signal at every voxels
% either fiber group pass through.

% Set the tensors for the FA fibers to CSF (Spheres)
fgFa_csf = fgFa;
d_ad = 0.5; d_rd = 0.5; % 
dParms(1) = d_ad;  dParms(2) = d_rd;  dParms(3) = d_rd;
fgFa_csf.Q = fgTensors(fgFa_csf, dParms);

% Merge Hits and CSF-FA
name = 'Merged Hits + (FA CSF)';
fgHit_fit = fgMerge(fgHit,fgFa_csf,name); 

% Merge Hits and FA modelled as CSF to find the voxel locations where all fibers go through. 
% Get roi coords
coords = fefgGet(fgHit_fit,'unique image coords');

%% (1) Test Hits and FA, 
% build LiFe with fgHit only, + CSF at the FA locations
[Afg_sim, Aiso_sim] = mctBuildDiffusionModel(dwi,fgHit_fit,coords,[],'mdwi');

% Simulate signal
w        = [.5*ones(size(fgHit.fibers)) ones(size(fgFa.fibers))]';
dSig_sim = Afg_sim * w;

% Add the baseline
w_iso    = ones(size(Aiso_sim,2),1);
baseline = Aiso_sim * w_iso;

% Add the baseline to dSig_sim
dSig_sim2 = dSig_sim + baseline;


% Build LiFe with the merged fiber group HITs + FAs.
[Afg, Aiso] = mctBuildDiffusionModel(dwi,fg,coords,[],'ones');
Afull = [Afg, Aiso];

% bootstrap to get some errorbars    

e_w = nan(size(Afull,2),nBoots);
dSig_sim_noise = zeros(length(dSig_sim),nBoots);
fprintf('Bootstrapping the error on the weights, %i\n\n',nBoots);

% Corrupt the diffusion signal with noise.
% Noiseis added as a proportion of the mean diffusion signal in each voxel.
sd = noiseLevel(nn); % .* mean(baseline);
mu = baseline;
for iBoot = 1:nBoots
    fprintf('.')
    noise = mu + sd .* randn(size(dSig_sim));% mctComputeRiceNoise(mu,sd,size(dSig_sim));
    dSig_sim_noise(:,iBoot) = noise + dSig_sim;
    
    % Recover the weights of the fibers using Microtrack
    e_w(:,iBoot) = mctFitDiffusionModel(Afull, dSig_sim_noise(:,iBoot), fitType);
end
fprintf('\n')

% Mean estimated weights:
mew{ss} = mean(e_w,2);
sdew{ss} = prctile(e_w,[2.5 97.5],2)';

% Predict the signal given the weigths.
dSig_pred =  mctComputePredictedSignal(Afull, mew{ss});

% Compute residual
res_dSig = dSig_sim - dSig_pred;

% plot the simulated signal and the predicted signal
mrvNewGraphWin('Signal prediction');
set(gcf,'Position',[72 166 1845 429])
% Simulated signal
a = plot(mean(dSig_sim_noise,2),'bo-');
hold on

% Confidence intervals of the simulated signal
plot([1:size(dSig_sim_noise,1);1:size(dSig_sim_noise,1)], ...
     prctile(dSig_sim_noise,[2.5 97.5],2)','b-');
% Isotropic component, mean voxel signal
b = plot(baseline,'k-'); 
% Predicted signal
c = plot(dSig_pred,'r.');  
legend([a,b,c],{'Simulated signal','Baseline (iso)','Predicted signal'})
ylabel('Diffusion signal')
xlabel('Voxel and diffusion directions')
set(gca,'xLim',[0 nbvecs*size(coords,1)], ...
        'xTick',[1:nbvecs:nbvecs*size(coords,1)+nbvecs], ...
        'xTickLabel',1:length([1:nbvecs:nbvecs*size(coords,1)+nbvecs]), ...
        'xGrid','on', ...
        'TickDir', 'out');
      drawnow
      savefig2(gcf, sprintf('dSig_pred_nNodes%i',sampleSpacing(ss)), fig_dir)

% Plot the Results of the weights estimation.
mrvNewGraphWin(sprintf('Fibers Hits #%i and FA #%i',length(fgHit.fibers),length(fgFa.fibers)));
set(gcf,'Position',[70   678   709   420])

% The recovered weigths
indx = 1:sum([length(fgHit.fibers),length(fgFa.fibers)]);
bar(mew{ss}(indx)); hold on

% The error around their estimates
plot([indx;indx],sdew{ss}(:,indx),'r-','lineWidth',2);

% The simulated weights
plot(1:length(fgHit.fibers),w(1:length(fgHit.fibers)),'go','MarkerSize',10);

% Format the plot
axis([0 sum([length(fgHit.fibers),length(fgFa.fibers)])+1 0 1.1 ]);
title(sprintf('LiFe Recovery of Simulated Weigths, Noise Level=%0.3f',noiseLevel(nn)));
ylabel('Fiber Weight');
xlabel(sprintf('Fiber Number (Hits = 1:%i)',length(fgHit.fibers)));

drawnow
savefig2(gcf, sprintf('weights_pred_nNodes%i',sampleSpacing(ss)), fig_dir)

end
end

% Plot the mean and the variance of the estimated Weights.
keyboard

return
