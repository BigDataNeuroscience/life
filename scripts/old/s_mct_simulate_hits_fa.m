function s_mct_simulate_hits_fa
% 
% function s_mct_simultate_hits_fa
%
% This function shows that given a fiber group containing hit-fibers and
% false-alarms fibers, LiFe can estimate the weights set for the *real*
% fibers (fibers really present in a volume of tissue) and eliminate
% (zero-out the weights for) the *fake* fibers (fibers not present in a
% tissue volume but mistakenly generated by a tracktography algorithm).
%
% The function does the following: 
% (1) simulates a few fibers.
%     - Some of these fibers are Hit-fibers, fibers assumed to be present in
%     a tissue volume. 
%     - The rest of the fibers are False Alarms fibers,
%     fibers assumed not to be present in the same tissue volume.
%
% (2) Generates diffusion signal using the Hits fibers only. Allowing the
%     weights for the fibers to be set as values between 0-1.
% (3) Merges the two fiber groups (Hits and FA). To generate the fiber
%     group that a tracktography algorithm could have generated given the
%     signal in the volume.
% (4) Set up the LiFe model using the merged fiber group.
% (5) Finds the weights for each fiber in the merged Fiber group (Hits+FA)
% (6) Estimates the variability of the estimated weights by bootstrapping (5) 
%     and adding Rician noise to the diffusion signal at each bootstrap
%     iteration.
% (7) Plots the estimated weights for each fiber with two-tailed 95%
%     confidence intervals (red) and the weights of the fibers used to simulate
%     the diffusion signal.
%
% Example: 
%
%    s_mct_simulate_hits_fa
%
% See also, test_mictrotrack_simulated_signal_recover
%
% (C) 2011 Stanford VISTA team. 

%% Simulate a fiber group, wit the associated DWI data and ROI coordinates.
plotTensors   = 0; % make a figure of the tensors
fitType       = 'tfocs'; % solver
S0            = 30; % Mean diffusivity
nbvecs        = 15;
bval          = 1000;
fiberType     = 'kc2'; % 'kc2', 'cs2', 'ps2', 'dc4'
noiseLevel    = 20; % this is the noise level relative to the standard deviation of the signal in a voxel
sampleSpacing = 2;% 2 4 8 16 32 64];  % Change this into units. Changing this will not run, because more voxels will be required for the FA fibers.
numClones     = 2;
clones_sd     = 0.1; % standard devian of the gaussian process centered at x,y,z coords of each node, in mm.
nBoots        = 5; % number of montecarlo-simulations
display3Dfibers = 0; % make a plot of the fibers in a 3D space.
savePbd = 0;         % save fibers as file.

[fgHit, fgFa, dwi] = mctSimulateFG2(fiberType, bval, nbvecs, S0,noiseLevel,sampleSpacing,numClones,clones_sd);

if display3Dfibers
  mctNfgDisplayStrands(fgHit);
  mctNfgDisplayStrands(fgFa);
end

if savePbd
  % Write the fibers to file (pbd).
  fgWrite(fgHit,fgHit.name,'pdb');
  fgWrite(fgFa,fgFa.name,'pdb');
  dwiNiftiFile = dwi.nifti.fname;
  niftiWrite(dwi.nifti,dwiNiftiFile);
end


% plot the tensors at the nodes
if plotTensors
    fgH = fgExtract(fgHit,1, 'keep');
    
    % plot agradient vector and the tensors. 
    mctPlotFibers(fgH,'Hit1',1,sampleSpacing);
    set(gcf,'Position',[1640 678 560 420])

    fgH = fgExtract(fgHit,2, 'keep');
    mctPlotFibers(fgH,'Hit2',1,sampleSpacing);   
    set(gcf,'Position',[1640 678 560 420])
 
    fgF = fgExtract(fgFa,1, 'keep');
    mctPlotFibers(fgF,'False Alarm1',1,sampleSpacing);
    set(gcf,'Position',[789 678 560 420])
    
    fgF = fgExtract(fgFa,2, 'keep');
    mctPlotFibers(fgF,'False Alarm2',1,sampleSpacing);
    set(gcf,'Position',[789 678 560 420])
   
    fgF = fgExtract(fgFa,3, 'keep');
    mctPlotFibers(fgF,'False Alarm3',1,sampleSpacing);
    set(gcf,'Position',[789 678 560 420])
   
    fgF = fgExtract(fgFa,4, 'keep');
    mctPlotFibers(fgF,'False Alarm4',1,sampleSpacing);
    set(gcf,'Position',[789 678 560 420])
    drawnow
end

% Merge Hits and FA fibers
name = 'Merged Hits+FAs';
fg   = fgMerge(fgHit,fgFa,name);

% Make a fiber group combining Hits and Fa, but setting the tensors for the
% FA fiebers to CSF. THis will allow us to create signal at every voxels
% either fiber group pass through.

% Set the tensors for the FA fibers to CSF (Spheres)
fgFa_csf = fgFa;
d_ad = 0.5; d_rd = 0.5; % 
dParms(1) = d_ad;  dParms(2) = d_rd;  dParms(3) = d_rd;
fgFa_csf.Q = fgTensors(fgFa_csf, dParms);

% Merge Hits and CSF-FA
name = 'Merged Hits + (FA CSF)';
fgHit_fit = fgMerge(fgHit,fgFa_csf,name); 

% Merge Hits and FA modelled as CSF to find the voxel locations where all fibers go through. 
% Get roi coords
coords = fefgGet(fgHit_fit,'unique image coords');

%% (1) Test Hits and FA, 
% build LiFe with fgHit only, + CSF at the FA locations
[Afg_sim, Aiso_sim] = mctBuildDiffusionModel(dwi,fgHit_fit,coords,[],'mdwi');

% Simulate signal
w        = [.5*ones(size(fgHit.fibers)) ones(size(fgFa.fibers))]';

% Normalize the weights so that they represent the total volume of the
% tissue. To do so we set the wanted weight for each fiber first, then this
% weight is normalize depending on the way fibers go through and meet int
% he volume. This allows to interpret the final weight as the proportion of
% tissue volume filled in by the fiber.
%
% 1. Set the wanted weight for each fiber, e.g., [.2 .5] for two fibers.
% 2. Choose the max proportion of tissue occupied by fibers, e.g. 0.8.
% 3. 
% 2. 

dSig_sim = Afg_sim * w;

% Add the baseline
w_iso    = ones(size(Aiso_sim,2),1);
baseline = Aiso_sim * w_iso;

% Add the baseline to dSig_sim
dSig_sim2 = dSig_sim + baseline;


% Build LiFe with the merged fiber group HITs + FAs.
[Afg, Aiso] = mctBuildDiffusionModel(dwi,fg,coords,[],'ones');
Afull = [Afg, Aiso];

% bootstrap to get some errorbars    

e_w = nan(size(Afull,2),nBoots);
dSig_sim_noise = zeros(length(dSig_sim),nBoots);
fprintf('Bootstrapping the error on the weights, %i\n\n',nBoots);

% Corrupt the diffusion signal with noise.
% Noiseis added as a proportion of the mean diffusion signal in each voxel.
sd = noiseLevel; % .* mean(baseline);
mu = baseline;
for iBoot = 1:nBoots
    fprintf('.')
    noise = mu + sd .* randn(size(dSig_sim));% mctComputeRiceNoise(mu,sd,size(dSig_sim));
    dSig_sim_noise(:,iBoot) = noise + dSig_sim;
    
    % Recover the weights of the fibers using Microtrack
    e_w(:,iBoot) = mctFitDiffusionModel(Afull, dSig_sim_noise(:,iBoot), fitType);
end
fprintf('\n')

% Mean estimated weights:
e_w = e_w;
mew = mean(e_w,2);
sdew = prctile(e_w,[2.5 97.5],2)';

% Predict the signal given the weigths.
dSig_pred =  mctComputePredictedSignal(Afull, mew);

% Compute residual
res_dSig = dSig_sim - dSig_pred;

% plot the simulated signal and the predicted signal
mrvNewGraphWin('Signal prediction');
set(gcf,'Position',[72 166 1845 429])
% Simulated signal
a = plot(mean(dSig_sim_noise,2),'bo-');
hold on

% Confidence intervals of the simulated signal
plot([1:size(dSig_sim_noise,1);1:size(dSig_sim_noise,1)], ...
     prctile(dSig_sim_noise,[2.5 97.5],2)','b-');
  
% Isotropic component, mean voxel signal
b = plot(baseline,'k-'); 
% Predicted signal
c = plot(dSig_pred,'r.');  
legend([a,b,c],{'Simulated signal','Baseline (iso)','Predicted signal'})
ylabel('Diffusion signal')
xlabel('Voxel and diffusion directions')
set(gca,'xLim',[0 nbvecs*size(coords,1)], ...
        'xTick',[1:nbvecs:nbvecs*size(coords,1)+nbvecs], ...
        'xTickLabel',1:length([1:nbvecs:nbvecs*size(coords,1)+nbvecs]), ...
        'xGrid','on', ...
        'TickDir', 'out');

% Plot the Results of the weights estimation.
mrvNewGraphWin(sprintf('Fibers Hits #%i and FA #%i',length(fgHit.fibers),length(fgFa.fibers)));
set(gcf,'Position',[70   678   709   420])

% The recovered weigths
indx = 1:sum([length(fgHit.fibers),length(fgFa.fibers)]);
bar(mew(indx)); hold on

% The error around their estimates
plot([indx;indx],sdew(:,indx),'r-','lineWidth',2);

% The simulated weights
plot(1:length(fgHit.fibers),w(1:length(fgHit.fibers)), 'go','MarkerSize',10);

% Format the plot
axis([0 sum([length(fgHit.fibers),length(fgFa.fibers)])+1 0 1.1 ]);
title(sprintf('LiFe Recovery of Simulated Weigths, Noise Level=%0.3f',noiseLevel));
ylabel('Fiber Weight');
xlabel(sprintf('Fiber Number (Hits = 1:%i)',length(fgHit.fibers)));

disp('Done TS Algo')
keyboard

return
